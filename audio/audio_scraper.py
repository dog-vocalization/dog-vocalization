#!/usr/bin/python

import pafy

import os
import subprocess
import re
import time
import glob

AUDIO_DIR = os.getcwd() + "/audio/audio_files/"
PLAYLIST_SEEDS = {
    "happy": "wrvqHw4wE_Q",
    "angry": "orEC1_Un_1w"
}


def get_audio(audio_dir = AUDIO_DIR):

    audio_files = {}
    for mood, video_id in PLAYLIST_SEEDS.iteritems():
        audio_files[mood] = glob.glob(audio_dir + mood.upper() + '*.wav')
        if len(audio_files[mood]) is 0:
            audio_files = download_audio()
            return audio_files

    return audio_files


"""
Wrapper for download_playlist that passes each distinct seed and groups it by
the associated mood

Returns the dictionary audio_files, mapping a mood to a list of associated audio
"""
def download_audio(audio_dir = AUDIO_DIR):

    audio_files = {}

    for mood, video_id in PLAYLIST_SEEDS.iteritems():
        audio_files[mood] = [] #not sure if this line is necessary
        
        wav_files = download_playlist(mood, video_id)
        audio_files[mood] = wav_files

    print "\n********** Finished downloading audio files \n"
    return audio_files


"""
Download's the audio of a YT mix playlist based on a seed video id

Returns the list of converted audio files downloaded.
"""
def download_playlist(mood, video_id, audio_dir = AUDIO_DIR):

    #seed_video to generate mix playlist id
    seed_video = pafy.new(video_id)
    playlist_id = seed_video.mix.plid
    
    #create a playlist meta object from the playlist id
    playlist_and_meta = pafy.get_playlist(playlist_id)
    #extract list of video urls from playlist meta object
    playlist = playlist_and_meta['items']
    
    #iterate over list of video urls to download their audio
    wav_files = []
    
    for x in xrange(-1,len(playlist)):
        #process seed video first, then playlist videos generated by seed video
        if x == -1:
            video = pafy.new(video_id)
        else:
            video = playlist[x]['pafy']
        
        stream = video.getbestaudio(preftype="m4a")
        title = re.sub(r'\W+', '', video.title.replace (" ", "_"))

        #initialize audio file paths
        m4a_file = audio_dir + mood.upper() + "_" + title + "." + stream.extension
        wav_file = m4a_file[:-4] + '.wav'

        print "m4a_file",m4a_file
        print "wav_file",wav_file
        
        #if file doesn't already exist, download it
        if not os.path.isfile(m4a_file):
            m4a_file = stream.download(filepath = m4a_file)
        
        #if file isn't already converted, convert it
        if not os.path.isfile(wav_file):
            wav_file = convert_to_wav(m4a_file)
        
        wav_files.append(wav_file)
        print "Downloaded {0}".format(wav_file)
    
    return wav_files


"""
Relies on users' FFMPEG install to convert m4a to wav
User MUST have FFMPEG installed on their system path/system environ variables

Returns path to new wav file.
"""
def convert_to_wav(m4a_file,audio_dir = AUDIO_DIR):
    
    ffmpeg_bin = "ffmpeg"
    wav_file = m4a_file[:-4] + '.wav'
    
    command = [ ffmpeg_bin, '-i', m4a_file, wav_file, '-y' ]
    print command
    conversionProcess = subprocess.Popen(command, stdout = subprocess.PIPE,env=dict(os.environ,PATH="PATH"))          
    
    # Wait until we're done converting the file
    while os.path.isfile(wav_file) is False:
        time.sleep(1)

    conversionProcess.stdout.close()


    # Delete the m4a file
    os.remove(m4a_file)
    
    #this method only works on Mac
    #command = [ 'find', audio_dir, '-name', '*.m4a', '-exec', 'rm', '-rf', '{}', ';' ]
    #deletionProcess = subprocess.Popen(command, stdout = subprocess.PIPE)

    # Wait until we're done deleting the old file
    while os.path.isfile(m4a_file) is True:
        time.sleep(1)

    #deletionProcess.stdout.close()
    return wav_file



